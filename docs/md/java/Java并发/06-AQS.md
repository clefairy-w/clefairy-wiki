AQS是AbstractQueuedSynchronizer的缩写，中文翻译是抽象队列同步器，它是Java并发包中的一个核心组件，为构建锁和其他同步组件提供一个可靠的框架。

AQS内部是维护一个int类型的同步状态，AQS定义了一系列方法来访问和修改同步状态，并维护了一个等待队列来管理那些获取资源失败的线程。当一个线程尝试获取资源而失败时，它会被加入到这个队列的尾部，并且在队列中等待。直到前驱节点（通常是当前持有资源的线程）释放资源，这个线程才会尝试再次获取资源。

我们在使用AQS来实现自己的同步器要继承这个类，并实现自己的获取和释放方法。比如Semaphore、CyclicBarrier、CountDownLatch、ReentrantLock等在其锁的实现中聚合了同步器，利用同步器实现锁的语义。在获取锁和释放锁的实现过程中，需要对同步状态进行更改，而同步器提供了3个方法(getState()、setState()和compareAndSetState(int expect,int update))来进行操作，这些方法能够保证同步状态的改变是安全的。

我们可以用AQS来实现独占模式的同步组件，比如JDK中的ReentrantLock，它每次只允许一个线程持有锁，其他线程都无法获取锁，直到持有锁的线程将锁释放。还可以实现共享模式的同步器，比如ReadWriteLock的读锁，就是共享模式工作，在没有线程持有写锁的情况下，允许多个线程持有读锁。

同步器的设计是基于模板方法模式的，同步器提供的模板方法基本分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态、查询同步队列中的等待线程情况。

#### 1. 同步队列

同步器依赖内部的双向同步队列来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点并将其加入同步队列，同时阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。