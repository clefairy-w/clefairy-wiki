#### 1. 锁分类

* 悲观锁 & 乐观锁

  悲观锁的核心思想是对数据被外界修改持保守态度。它假设数据很可能会被其他线程修改，因此在数据处理过程中通过加锁来防止其他线程对数据进行修改。

  乐观锁机制采取了一种宽松的加锁机制。它假设数据通常情况下不会造成冲突，因此在数据提交更新时才会检查是否有其他线程也尝试修改了这个数据。

  在Java编程中，乐观锁可以通过原子变量类（如AtomicInteger）来实现，或者通过CAS（比较并交换）操作来实现无锁的线程安全编程。

* 公平锁 & 非公平锁

  公平锁：朴素的公平就是先进先出，公平锁就是竞争锁的时候要排队

  非公平锁：锁的竞争是非公平的，后来的线程也可以直接参与锁竞争

* 独占锁 & 共享锁

  独占锁：一个线程能持有锁，其他线程要阻塞等待，直到持有锁的线程释放锁后，其他线程再重新竞争

  共享锁：锁可以被多个线程持有，典型的就是ReadWriteLock的读锁，在没有线程持有写锁时，读锁可以被多个线程持有

* 重入锁
* 读写锁

#### 2. Lock

Lock是一个接口，它定义了锁获取和释放的基本操作，提供了synchronized关键字所不具备的特性，如尝试非阻塞地获取锁(当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁)、能被中断地获取锁(获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放)、超时获取锁(在指定的截止时间之前获取锁，如果截止时间到了仍无法获取锁，则返回)。Lock接口的实现类主要探索以下三个：ReadLock、WriteLock、ReentrantLock。

##### 2.1. ReentrantLock

##### 2.2. ReadLock

##### 2.3. WriteLock

#### 3. LockSupport

#### 4. Condition接口

#### 5. StampedLock

* ##### 5.1. ReadLockView

* ##### 5.2. WriteLockView

#### 6. ReadWriteLock

##### 6.1. ReentrantReadWriteLock

