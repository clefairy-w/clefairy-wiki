#### 1.redis实现的分布式锁

##### 1.1.概念

* 基于redis的setnx指令，该指令当redis存在key则创建失败，不存在key则创建成功
* 加锁：setnx设置key，设置成功的获得锁
* 解锁：删除key，锁持有者可以删除

##### 1.2.问题

* 死锁

  > 在setnx设置的key没有超时时间时
  >
  > * 正常死锁，临界资源，循环等待
  > * 锁持有者，崩溃，导致锁没有释放（key没有删除掉）
  >
  > setnx设置key时添加超时时间：可以解决死锁
  >
  > * 锁持有者的同步代码执行时间超过锁的有效时间，可能导致临界资源不是同步访问
  >
  > 带来新问题：
  >
  > 锁持有者的同步代码执行超过锁的有效时间，在释放锁是可能释放错误的锁（释放了不是自己的锁）
  >
  > * 通过给value设置一个随机数来保证释放的锁是自己的锁。

* 不支持阻塞

  > 自行实现自旋：消耗cpu性能

#### 2.zookeeper实现的分布式锁

##### 2.1.基于单个临时节点

* 利用zk的节点只能被一个客户端创建成功的特性
* 多个客户端，创建临时节点成功的客户端，获得锁
* 没有获得锁的客户端，在临时节点上监听，当临时节点移除时，重新进行竞争

##### 2.2.基于临时顺序节点

* 利用zk临时顺序节点的特点
* 多个客户端创建的节点是有顺序的，序号最小的获得锁
* 每个客户端去监听比它序号小的前的一个节点
* 释放锁时，就是删除自己创建的节点，后一个节点监听到节点删除，就会判断自己是不是最小的，若是最小的即可获取锁

#### 3.其他分布式锁

##### 3.1.基于Mysql实现分布式锁

* 利用Mysql的主键唯一性