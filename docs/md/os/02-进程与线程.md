#### 1.进程

  引入进程，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性

  进程是一个正在执行程序的实例，是系统进行资源分配和调度的一个独立单位，是动态的。

##### 1.1. 进程的组成

  进程是系统进行资源分配和调度的基本单位，最核心的是进程控制块(PCB)

* 进程控制块(PCB)

  进程创建时，操作系统为它新建一个PCB，存在内存中，任意时刻都可存取，并在进程结束时被删除

  在进程的整个生命周期中，系统时通过PCB对进程进行控制

  PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单、CPU上下文

  * 进程描述信息：进程标识符，每个进程都有一个唯一的标识符；用户标识符，表示进程归属的用户
  * 进程控制和管理信息：进程当前状态；进程优先级；
  * 资源分配清单
  * CPU上下文: 主要指CPU中各寄存器的值

* 程序段

* 数据段

##### 1.2.进程的状态与转换

 进程通常有五种状态

* 运行态
* 就绪态
* 阻塞态

* 创建态

* 终止态

  就绪态和阻塞态存在区别：就绪态是指进程仅缺少CPU，只要获得CPU就立即运行；而阻塞态是指进程需要其他资源(除了CPU)或等待某一事件。

进程状态转换

* 就绪态->运行态: 处于就绪态的进程被调度后，获得CPU资源(分派CPU的时间片)，进程由就绪态转换为运行态
* 运行态->就绪态: 处于运行态的进程在事件片用完后，不得不让出CPU，从而进程由运行态转为就绪态。
* 运行态->阻塞态: 进程请求某一资源的使用和分配或等待某一事件的发生时，就从运行态转换为阻塞态。
* 阻塞态->就绪态: 进程等待的事件到来时，如I/O操作完 成或中断结束时，中断处理程序必须将相应进程的状态由阻塞态转换为就绪态。

##### 1.3. 进程的通信

* 共享存储
* 消息传递
* 管道通信

#### 2. 线程

 进程的目的是使多道程序并发执行，提高资源利用率和系统吞吐量；引入线程目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能

##### 2.1. 线程与进程比较

* 调度
* 并发性
* 拥有资源
* 独立性
* 系统开销
* 支持多处理器系统

#### 3. CPU调度

  程序系统中，存在进程争用CPU的情况。CPU调度是对CPU进行分配，即从就绪队列中按照一定的算法选择一个进程并将CPU分配给它运行，以实现进程并发地执行，这样能够更合理地处理计算机的软/硬件资源。

  调度层次：高级调度(作业调度)->中级调度(内存调度)->低级调度(进程调度)

  用于调度和分派CPU的组件称为调度程序，是操作系统内核程序。通常由三部分组成，包括排队器、分派器、上下文切换器

 ##### 3.1. 进程调度的方式

  进程调度方式，是指当某个进程正在CPU上执行时，有优先权更高的进程进入就绪队列，此时CPU应如何分配。

  进程调度方式有两种：非抢占调度方式、抢占调度方式

##### 3.2. 上下文切换

  切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为上下文切换。进程上下文采用进程PCB表示，包括CPU寄存器的值、进程状态和内存管理信息等。

  上下文切换的流程：

​    挂起当前进程，将CPU上下文保存到PCB，包括程序计数器和其他寄存器

​    将进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列

​    选择另一个进程执行，并更新其PCB。

​    恢复新进程的CPU上下文

​    跳转到新进程PCB中的程序计数器所指向的位置执行

##### 3.3. 调度算法

  操作系统中存在多种多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的算法两者都适用。

  先来先服务调度算法、端作业优先调度算法、优先级调度算法、时间片轮转调度算法等

#### 4.死锁

  多进程并发执行会带来死锁，所谓死锁，是指多个进程因竞争资源而造成互相等待对方手里的资源，使得各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进。

  死锁与饥饿不同，饥饿是进程在信号量内无穷等待的情况。

 ##### 4.1. 死锁产生的必要条件

  1). 互斥条件：在一段时间内某资源仅为一个进程占有，其他进程请求该资源时只能进行等待

  2). 不可剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，只能由获得该资源的进程自己主动释放。

  3). 请求并持有条件：进程已经保持至少一个资源，又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，对自己已获得的资源保持不放。

  4). 循环等待条件：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

##### 4.2. 死锁的处理策略

  1). 死锁预防：设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。

      - 破坏互斥条件->将只能互斥使用的资源改造为允许共享使用，但是有时为了系统安全，需要保护互斥性。
      - 破坏不可剥夺条件
      - 破坏循环等待条件->可以采用顺序资源分配法

  2). 避免死锁：在资源的动态分配过程中，用某种方法防止进入不安全状态。

* 安全算法
* 银行家算法

  3). 死锁检测: 允许进程在运行过程中发生死锁，通过系统的检测及时检测出死锁的发生，然后才去某种措施解除死锁。

* 可用资源分配图来检测系统所处的状态是否为死锁状态。
* 解除死锁的方式：资源剥夺、撤销进程、进程回退



参考文献

[1]王道论坛. 2025年计算机网络考研复习指导[M]. 北京: 电子工业出版社, 2024
